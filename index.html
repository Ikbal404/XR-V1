<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>three.js xr - dragging (dummy depth)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #808080; }
    #info {
      position: absolute; left: 12px; top: 12px; z-index: 2;
      color: #fff; font-weight: 600; background: rgba(0,0,0,0.25);
      padding: 6px 10px; border-radius: 6px;
    }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="info">three.js xr - dragging (using dummy depth)</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.153.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.153.0/examples/jsm/controls/OrbitControls.js';
    import { XRButton } from 'https://unpkg.com/three@0.153.0/examples/jsm/webxr/XRButton.js';
    import { XRControllerModelFactory } from 'https://unpkg.com/three@0.153.0/examples/jsm/webxr/XRControllerModelFactory.js';

    let camera, scene, renderer;
    let controller1, controller2;
    let controllerGrip1, controllerGrip2;
    let group;
    let raycaster;
    const intersected = [];
    const tempMatrix = new THREE.Matrix4();
    let isDepthSupplied = false;
    let dummyDepthTexture = null;
    let dummyWidth = 0, dummyHeight = 0;

    init();
    animate();

    function init() {
      // Scene + camera + renderer
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x808080);

      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 100);
      camera.position.set(0, 1.6, 3);

      const container = document.createElement('div');
      document.body.appendChild(container);

      const controls = new OrbitControls(camera, container);
      controls.target.set(0, 1.6, 0);
      controls.update();

      // floor
      const floorGeometry = new THREE.PlaneGeometry(6, 6);
      const floorMaterial = new THREE.ShadowMaterial({ opacity: 0.25 });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = - Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      scene.add(new THREE.HemisphereLight(0xbcbcbc, 0xa5a5a5, 1.5));
      const light = new THREE.DirectionalLight(0xffffff, 2.5);
      light.position.set(0, 6, 0);
      light.castShadow = true;
      scene.add(light);

      group = new THREE.Group();
      scene.add(group);

      // Create dummy depth texture (gradient) - used as fallback
      createDummyDepthTexture();

      // geometries + shader material (using sampler2D, not sampler2DArray)
      const geometries = [
        new THREE.BoxGeometry(0.2, 0.2, 0.2),
        new THREE.ConeGeometry(0.2, 0.2, 64),
        new THREE.CylinderGeometry(0.2, 0.2, 0.2, 64),
        new THREE.IcosahedronGeometry(0.2, 8),
        new THREE.TorusGeometry(0.2, 0.04, 64, 32)
      ];

      for (let i = 0; i < 40; i++) {
        const geo = geometries[Math.floor(Math.random() * geometries.length)];
        const mat = new THREE.ShaderMaterial({
          vertexShader: /* glsl */`
            varying vec3 vNormal;
            void main() {
              vNormal = normalize(normalMatrix * normal);
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: /* glsl */`
            varying vec3 vNormal;
            uniform vec3 diffuseColor;
            uniform float emissive;
            uniform sampler2D depthColor;
            uniform float depthWidth;
            uniform float depthHeight;

            #define saturate(a) clamp(a,0.0,1.0)

            float Depth_GetCameraDepthInMeters(const sampler2D depthTexture, const vec2 uv) {
              return texture(depthTexture, uv).r;
            }

            // simple single-sample occlusion; keep it light for compatibility
            float Depth_GetOcclusion(const sampler2D depthTexture, const vec2 uv, float assetDepthM) {
              float depthMm = Depth_GetCameraDepthInMeters(depthTexture, uv);
              float diff = depthMm - assetDepthM;
              // tolerance scaled to distance
              float tol = 0.003 * assetDepthM;
              return saturate(1.0 - diff / tol);
            }

            void main() {
              vec3 normal = normalize(vNormal);
              vec3 diffuse = diffuseColor;
              float spec = pow(max(dot(normal, normalize(vec3(0,0,1))), 0.0), 64.0);
              vec3 color = diffuse * (1.0 - 0.2) + vec3(spec) * 0.2;

              // depth effect (if depthWidth > 0)
              if (depthWidth > 0.0) {
                vec2 uv = vec2(gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight);
                float assetDepthM = gl_FragCoord.z;
                float occl = Depth_GetOcclusion(depthColor, uv, assetDepthM);
                // highlight when in front (small distance)
                float depthScene = Depth_GetCameraDepthInMeters(depthColor, uv);
                float d = abs(assetDepthM - depthScene);
                float v = 0.003;
                float closeness = saturate(v - d) / v;
                color += vec3(closeness * 1.5, closeness * 1.5, closeness * 6.0);
                color = mix(color, vec3(0.0), occl * 0.6);
              }

              gl_FragColor = vec4(color * (1.0 + emissive), 1.0);
            }
          `,
          uniforms: {
            diffuseColor: { value: new THREE.Color(Math.random() * 0xffffff) },
            emissive: { value: 0.0 },
            depthColor: { value: dummyDepthTexture },
            depthWidth: { value: dummyWidth },
            depthHeight: { value: dummyHeight }
          }
        });

        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.x = Math.random() * 4 - 2;
        mesh.position.y = Math.random() * 2;
        mesh.position.z = Math.random() * 4 - 2;
        mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        mesh.scale.setScalar(Math.random() + 0.5);
        mesh.castShadow = true;
        group.add(mesh);
      }

      // Add a normal-material cube as sanity-check (should be visible when entering XR)
      const testCube = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.15,0.15), new THREE.MeshNormalMaterial());
      testCube.position.set(0, 1.5, -1);
      scene.add(testCube);

      // renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.xr.enabled = true;
      // helpful for debugging shaders:
      renderer.debug.checkShaderErrors = true;
      document.body.appendChild(renderer.domElement);

      // XR button (optional features include depth-sensing; but we will still use dummy)
      document.body.appendChild(XRButton.createButton(renderer, {
        optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'layers', 'depth-sensing'],
        depthSensing: { usagePreference: ['gpu-optimized', 'cpu-optimized'], dataFormatPreference: ['luminance-alpha','float32'] }
      }));

      // controllers
      controller1 = renderer.xr.getController(0);
      controller1.addEventListener('selectstart', onSelectStart);
      controller1.addEventListener('selectend', onSelectEnd);
      scene.add(controller1);

      controller2 = renderer.xr.getController(1);
      controller2.addEventListener('selectstart', onSelectStart);
      controller2.addEventListener('selectend', onSelectEnd);
      scene.add(controller2);

      const controllerModelFactory = new XRControllerModelFactory();
      controllerGrip1 = renderer.xr.getControllerGrip(0);
      controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
      scene.add(controllerGrip1);

      controllerGrip2 = renderer.xr.getControllerGrip(1);
      controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
      scene.add(controllerGrip2);

      // laser line for controllers
      const lineGeom = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1) ]);
      const line = new THREE.Line(lineGeom);
      line.name = 'line';
      line.scale.z = 5;
      controller1.add(line.clone());
      controller2.add(line.clone());

      raycaster = new THREE.Raycaster();
      window.addEventListener('resize', onWindowResize);
    }

    function createDummyDepthTexture() {
      // Create a gradient canvas to simulate depth map: top (near) -> bottom (far)
      const scale = Math.max(1, Math.floor(window.devicePixelRatio));
      const w = 1024; // fixed internal resolution (power-of-two helps)
      const h = 1024;
      dummyWidth = w;
      dummyHeight = h;

      const c = document.createElement('canvas');
      c.width = w;
      c.height = h;
      const ctx = c.getContext('2d');

      // draw vertical grayscale gradient (near at top -> white, far at bottom -> black)
      const grad = ctx.createLinearGradient(0, 0, 0, h);
      grad.addColorStop(0.0, 'rgba(255,255,255,1)'); // near (depth small)
      grad.addColorStop(1.0, 'rgba(0,0,0,1)');       // far (depth large)
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,w,h);

      // optionally add some radial variations to make occlusion visible
      ctx.globalAlpha = 0.12;
      for (let i=0;i<12;i++){
        ctx.beginPath();
        const rx = Math.random() * w;
        const ry = Math.random() * h;
        const r = 50 + Math.random()*300;
        ctx.fillStyle = 'rgba(0,0,0,1)';
        ctx.arc(rx,ry,r,0,Math.PI*2);
        ctx.fill();
      }

      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.format = THREE.LuminanceFormat;
      tex.generateMipmaps = false;

      dummyDepthTexture = tex;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onSelectStart(event) {
      const controller = event.target;
      const intersections = getIntersections(controller);
      if (intersections.length > 0) {
        const intersection = intersections[0];
        const object = intersection.object;
        if (object.material && object.material.uniforms) object.material.uniforms.emissive.value = 1.0;
        controller.attach(object);
        controller.userData.selected = object;
      }
      controller.userData.targetRayMode = (event.data && event.data.targetRayMode) ? event.data.targetRayMode : controller.userData.targetRayMode;
    }

    function onSelectEnd(event) {
      const controller = event.target;
      if (controller.userData.selected !== undefined) {
        const object = controller.userData.selected;
        if (object.material && object.material.uniforms) object.material.uniforms.emissive.value = 0.0;
        group.attach(object);
        controller.userData.selected = undefined;
      }
    }

    function getIntersections(controller) {
      controller.updateMatrixWorld();
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      return raycaster.intersectObjects(group.children, false);
    }

    function intersectObjects(controller) {
      if (controller.userData.targetRayMode === 'screen') return;
      if (controller.userData.selected !== undefined) return;

      const line = controller.getObjectByName('line');
      const intersections = getIntersections(controller);
      if (intersections.length > 0) {
        const intersection = intersections[0];
        const object = intersection.object;
        if (object.material && object.material.uniforms) object.material.uniforms.emissive.value = 1.0;
        intersected.push(object);
        line.scale.z = intersection.distance;
      } else {
        line.scale.z = 5;
      }
    }

    function cleanIntersected() {
      while (intersected.length) {
        const obj = intersected.pop();
        if (obj.material && obj.material.uniforms) obj.material.uniforms.emissive.value = 0.0;
      }
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render() {
      // Try to read real depth texture if available from XR session.
      // If not available, keep using dummyDepthTexture created earlier.
      if (renderer.xr && renderer.xr.hasDepthSensing && typeof renderer.xr.hasDepthSensing === 'function' && renderer.xr.hasDepthSensing()) {
        // attempt to fetch depth texture and size from renderer.xr (if runtime provides)
        try {
          const realDepth = (typeof renderer.xr.getDepthTexture === 'function') ? renderer.xr.getDepthTexture() : null;
          const realW = (typeof renderer.xr.getDepthWidth === 'function') ? renderer.xr.getDepthWidth() : null;
          const realH = (typeof renderer.xr.getDepthHeight === 'function') ? renderer.xr.getDepthHeight() : null;

          if (realDepth) {
            // supply real depth to materials
            group.children.forEach(child => {
              if (child.material && child.material.uniforms) {
                child.material.uniforms.depthColor.value = realDepth;
                child.material.uniforms.depthWidth.value = realW || dummyWidth;
                child.material.uniforms.depthHeight.value = realH || dummyHeight;
              }
            });
            isDepthSupplied = true;
          } else {
            // no real depth available: keep dummy
            group.children.forEach(child => {
              if (child.material && child.material.uniforms) {
                child.material.uniforms.depthColor.value = dummyDepthTexture;
                child.material.uniforms.depthWidth.value = dummyWidth;
                child.material.uniforms.depthHeight.value = dummyHeight;
              }
            });
            isDepthSupplied = false;
          }
        } catch (e) {
          // fallback to dummy in case of any runtime exceptions
          group.children.forEach(child => {
            if (child.material && child.material.uniforms) {
              child.material.uniforms.depthColor.value = dummyDepthTexture;
              child.material.uniforms.depthWidth.value = dummyWidth;
              child.material.uniforms.depthHeight.value = dummyHeight;
            }
          });
          isDepthSupplied = false;
        }
      } else {
        // no depth-sensing available -> use dummy
        group.children.forEach(child => {
          if (child.material && child.material.uniforms) {
            child.material.uniforms.depthColor.value = dummyDepthTexture;
            child.material.uniforms.depthWidth.value = dummyWidth;
            child.material.uniforms.depthHeight.value = dummyHeight;
          }
        });
        isDepthSupplied = false;
      }

      cleanIntersected();
      intersectObjects(controller1);
      intersectObjects(controller2);

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>